# 基本类型和引用类型的值
JavaScript 变量松散类型的本质，决定了它只在特定的时间用于保存特定值的一个名字而已。由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。
这是 JavaScript 变量一个有趣、强大又容易出问题的特性。

---
## 基本类型和引用类型的值
- **基本类型值**：简单的数据段，按**值**访问，可以操作保存在变量中的实际的值
- **引用类型值**：可能由多个值构成的**对象**，按**引用**访问，操作对象的引用而不能直接操作对象的内存空间
*在将一个值赋给变量时，解析器**必须确定**这个值是基本类型值还是引用类型值*

---
### 动态的属性
- 不能给基本类型的值添加属性，尽管这样做不会导致任何错误；
- 只能给引用类型值动态地添加属性和方法，如果对象不被销毁或者这个属性/方法不被删除，这个属性/方法将一直存在

---
### 复制变量值
- 复制基本类型值：两个变量值之间**完全独立**
- 复制引用类型值：复制的是**指向对象的引用**，指向同一个储存在堆中的一个对象，因此改变其中一个变量，另一个也会受到影响

---
### 传递参数
访问变量有按值和按引用两种方式，而**参数只能按值传递**
- 传递基本类型值：被传递的值会被复制给一个局部变量
- 传递引用类型值：会把**这个值在内存中的地址**复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部

### 检测类型
- 检测基本类型： ***typeof*** 操作符，确定变量是字符串、数值、布尔值还是 undefined
    - 检测函数时返回 *function*
    - 检测正则表达式返回 **function**（Safari 5 及以前版本、Chrome 7 及之前版本）/ **Object**（IE 和Firefox）
- 检测引用类型： ***instanceof*** 操作符，它检测基本类型时始终返回 **false**
    - 根据规定，所有引用类型的值都是 Object 的实例，在用 instanceof 检测引用类型值时，始终返回 **true**
`alert(person instanceof Object)`       
`alert(person instanceof Array)`
`alert(person instanceof RegExp)`

## 执行环境和作用域

- **执行环境**：定义了变量或函数有权访问的其他数据，决定了它们各自的行为
- 类型：*全局和局部（函数）*
- 每个执行环境都有与之关联的**变量对象**，环境定义的所有变量和函数都保存在这个对象中。
- 每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，函数执行后，栈将其环境弹出，把控制器返回给之前的执行环境
- 当代码在一个环境中执行时，会创建变量对象的一个**作用域链**，来保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终是当前执行的代码所在环境的变量对象。全局执行环境的变量对象始终是作用域链中的最后一个对象。
- **标识符解析**是沿着作用域链一级一级地搜索标识符的过程，搜索过程始终从作用域的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）

---
### 延长作用域链
有些语句可以在作用域的前端临时增加一个变量对象，该变量对象会在代码执行后被移除
- ***try-catch***语句的 ***catch*** 块，会创建一个新的变量对象，其中包含的就是被抛出的错误对象的声明
```js
function builderUrl() {
    var qs = "?debug=true";

    with(location) {
        var url = href + qs;     //href: location.href
    }
    return url;
}
```
在 IE8 及之前的 JavaScript 实现中，在 **catch** 语句中捕获的错误对象会被添加到执行环境的变量对象，而不是 **catch** 语句的变量对象中，即在 **catch** 块的外部也可以访问到错误对象。IE9 修复了此问题。
- ***with*** 语句，会将指定的对象添加到作用域链中