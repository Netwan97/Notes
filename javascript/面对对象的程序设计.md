ECMAScript 支持面对对象（Object-Oriented）编程，但不使用类或接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。

---
## 理解对象

### 属性类型

- 数据属性
    - **\[[Configurable]]** ，默认值 **true**，表示能否通过 *delete* 删除属性从而重新定义属性，能否 修改属性的特性，或者能否把属性修改为访问器属性
    - **\[[Enumerable]]**，默认值 **true**，表示能否通过 *for-in* 循环返回属性
    - **\[[Writable]]**，默认值 **true**，表示能否修改属性的值
    - **\[[Value]]**，默认值 **undefined**
    - ***Object.defineProperty()*** ，用于修改属性默认的特性，接收三个参数：*属性所在的对象 + 属性的名字 + 一个描述符对象（该对象属性为：configurable、enumerable、writable、value）*
        - 若不指定，configurable、enumerable、writable 特性的默认值都是 **false**；
        - 若某属性的值是只读的（writable 设为 false），那么对此属性的赋值操作，在非严格模式下会被忽略，在严格模式下会报错；
        - 一旦把属性定义为不可配置的（configurable 设置为 false），就不能再把它变回可配置，此时再调用此方法修改除 writable 之外的特性，都会报错；
        - 不建议在 IE8 中使用此方法。
- 访问器属性
    - **\[[Configurable]]**，同上；
    - **\[[Enumerable]]**，同上；
    - **\[[Get]]**，默认值 **undefined**，在**读取**属性时调用的函数；
    - **\[[Set]]**，默认值 **undefined**，在**写入**属性时调用的函数；
    - 访问器属性不能直接定义，必须使用
    ***Object.defineProperty()*** 来定义。
        - 支持的有：IE9+（IE8 部分实现）、Firefox 4+、Safari 5+、Opera 12+ 和 Chrome
        - 在不支持此方法的浏览器中，不能修改 **\[[Configurable]]** 和 **\[[Enumerable]]**
        - 定义浏览器的旧有非标准方法： ***\_\_defineGetter__*** 和 ***\_\_defineSetter__***
    ```js
    var book = {
        _year: 2004,         // _year 前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性
        edition: 1
    }

    Object.defineProperty(book, "year", {
        get: function() {
            return this._year;
        },
        set: function(newVale) {
            if(newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        }
    });

    book.year = 2005;          // 访问器属性 year
    alert(book.edition);            // 2

    // 用旧有方法写
    book.__defineGetter__("year", function() {
            return this._year;
        });
    
    book.__defineSetter__("year", function(newVale) {
            if(newValue > 2004) {
                this._year = newValue;
                this.edition += newValue - 2004;
            }
        });
    ```
---
        
### 定义多个属性

- ***Object.defineProperties()*** 方法，接收两个参数：要添加和修改其属性的对象 + 对象属性与前者要添加和修改的属性一一对应的对象
```js
var book = {};

Object.defineProperties(book, {
    _year: {
        writable: true,
        value: 2004
    },
    edition: {
        writable: true,
        value: 1
    }
})
```
---

### 读取属性的特性
- ***Object.getOwnPropertyDescriptor()*** 方法，取得给定属性的描述符，接收两个参数：属性所在的对象 + 要读取其描述符的属性名称，返回一个包含访问器属性或数据属性的对象
    - 可针对任何对象——包括 **DOM** 和 **BOM** 对象使用此方法
    - 支持的有：IE9+、Firefox 4+、Safari 5+、Opera 12+ 和 Chrome
---
## 创建对象

### 工厂模式
- 使用同一个接口（Object 构造函数或对象字面量）创建很多对象，会产生大量重复代码
- 考虑到在 ECMAScript 中无法创建**类**，开发人员发明了一种**函数**来**封装**以特定接口创建对象的细节
- 解决了创建多个相似对象的问题，却没有解决对象识别的问题（即怎样知道一个对象的类型）
```js
function creatPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        alert(this.name);
    };
    return o;
}

var person1 = creatPerson("Greg", 29, "Engineer");
var person2 = creatPerson("John", 21, "Doctor");
```
---

### 构造函数模式
- 可创建自定义的构造函数，从而定义自定义对象类型的属性和方法，可以将它的实例标识为一种特定的类型
- 构造函数名以大写字母开头，非构造函数应以小写字母开头
- 创建构造函数的实例，要使用 **new**操作符
- 构造函数的实例对象都有 **constructor** 属性，该属性指向构造函数
- **缺点**：每个方法在每个实例上都重新创建了一遍，在 ECMAScript 中函数是对象，每定义一个函数也就实例化一个对象，因此**不同实例上的同名函数不相等**
- 可：作构造函数使用 / 作普通函数调用 / 在另一个对象的作用域中调用
```js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {          
        alert(this.name);
    };

// 解决多个函数做同一件事情，将上面方法改写为：
    this.sayName = sayName;
}

// 在函数外部定义全局函数
    function sayName() {
        alert(this.name);
    }

var person1 = new Person("Greg", 29, "Engineer");
var person2 = new Person("John", 21, "Doctor");

alert(person1.constructor == Person);            // true
alert(person1 instanceof Object);                // true
alert(person1 instanceof Person);                // true
alert(person1.sayName == person2.sayName)        // false

// 作普通函数调用
Person("Greg", 29, "Engineer");         // 添加到 window
window.sayName();           // "Greg"

// 在另一个对象的作用域中调用
var o = new Object();
Person.call(o, "John", 21, "Doctor");
o.sayName();                // "John"
```
- 以这种方式定义的构造函数是定义在 **Global** 对象（在浏览器中是 **window** 对象）中的
---

### 原型模式
- ***prototype*** （原型）属性，是一个指针，指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性和方法，即通过构造函数而创建的那个对象实例的原型对象
- 使用原型对象可以让所有对象实例共享它所包含的属性和方法
- 不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中
```js
function Person() {

}

Person.prototype.name = "Greg";
Person.prototype.age = 29;
Person.prototype.job = "Doctor";
Person.prototype.sayName = function() {
    alert(this.name);
}

var person1 = new Person();
var person2 = new Person();
alert(person1.sayName == person2.sayName);        // true    
```
- 只要创建一个函数，就会根据一组特定规则为该函数创建一个 ***prototype*** 属性，这个属性指向函数的原型对象
- 默认所有原型对象都会自动获得一个 ***constructor*** （构造函数）属性，指向 ***prototype*** 属性所在的函数
    - ***constructor*** 属性也是共享的，可以通过对象实例访问
- 当调用构造函数创建一个新实例后，该实例内部将包含一个指针（内部属性），指向构造函数的原型对象。
    - ECMA-262 第5版中称这个指针为 \[[Prototype]] ，虽在脚本中没有标准方式访问 \[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性 ***\_\_proto__***
    - 这个连接存在于实例和构造函数的原型对象之间，而不是存在于实例与构造函数之间
    ```js
    alert(person1.__proto__ == Person.prototype);        // true
    alert(Person.prototype.constructor == Person);        // true
    ```
    - ***isPrototypeOf()*** 方法，确定对象之间的关系
    ```js
    alert(Person.prototype.isPrototypeOf(person1));      // true
    ```
    - ***Object.getPrototypeOf()*** 方法，用途同上,返回 \[[Prototype]] 的值，支持的有：IE9+、Firefox 3.5+、Safari 5+、Opera 12+ 和 Chrome
    ```js
    alert(Object.getPrototypeOf(person1) == Person.prototype);    // true
    alert(Object.getPrototypeOf(person1).name);       // "Greg"
    ```




JavaScript 主要通过原型链实现继承。